{"meta":{"title":"张晨曦的博客","subtitle":"个人博客","description":"技术分享 工作心得 生活感悟","author":"张晨曦","url":"https://sombreknight.gitee.io","root":"/"},"pages":[{"title":"分类","date":"2021-01-09T02:59:20.699Z","updated":"2021-01-09T02:59:20.699Z","comments":false,"path":"index.html","permalink":"https://sombreknight.gitee.io/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-01-09T03:02:07.343Z","updated":"2021-01-09T03:02:07.343Z","comments":false,"path":"/404.html","permalink":"https://sombreknight.gitee.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-01-09T06:23:36.265Z","updated":"2021-01-09T06:23:36.257Z","comments":false,"path":"about/index.html","permalink":"https://sombreknight.gitee.io/about/index.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#123; &quot;name&quot;: &quot;张晨曦&quot;, &quot;age&quot;: 24, &quot;profession&quot;: &quot;Java Developer&quot;, &quot;experience&quot;: &quot;2年&quot;, &quot;address&quot;: &quot;四川省成都市&quot;, &quot;education&quot;: &quot;本科&quot;, &quot;github&quot;: &quot;https://github.com/SombreKnight&quot;, &quot;blog&quot;: &quot;https://sombreknight.github.io&quot;, &quot;email&quot;: &quot;dlmu_zhangchenxi@foxmail.com&quot;, &quot;description&quot;: &quot;五年开发经验的两年Java工程师&quot;, &quot;skills&quot;: &#123; &quot;Java&quot;: [ &quot;Basic Java&quot;, &quot;Java Collection&quot;, &quot;Java IO&quot;, &quot;Java Concurrent&quot;, &quot;JVM &amp; GC&quot; ], &quot;Web FrameWork&quot;: [ &quot;Spring&quot;, &quot;SpringMVC&quot;, &quot;SpringBoot&quot; ], &quot;SpringCloud&quot;: [ &quot;Eureka&quot;, &quot;Ribbon&quot;, &quot;Open Feign&quot;, &quot;Hystrix&quot;, &quot;GateWay&quot; ], &quot;SpringCloudAlibaba&quot;: [ &quot;Nacos&quot;, &quot;Sentinel&quot;, &quot;Dubbo&quot;, &quot;Seata&quot; ], &quot;Web Security&quot;: [ &quot;XSS&quot;, &quot;CSRF&quot;, &quot;SQL injection&quot;, &quot;Upload vulnerability&quot;, &quot;Download vulnerability&quot;, &quot;Url Jump vulnerability&quot; ], &quot;MiddleWare&quot;: [ &quot;Redis&quot;, &quot;Zookeeper&quot;, &quot;RabbitMQ&quot;, &quot;Kafka&quot; ], &quot;Software Engineering&quot;: [ &quot;Design Parttern&quot;, &quot;Code Clean Way&quot;, &quot;Refactor&quot;, &quot;DDD&quot; ], &quot;Linux&quot;: [ &quot;basic cmd&quot;, &quot;shell&quot;, &quot;basic ops skills&quot; ], &quot;BigData&quot;: [ &quot;Hadoop&quot;, &quot;Spark&quot;, &quot;Flink&quot; ], &quot;Others&quot;: [ &quot;SVN&quot;, &quot;GIT&quot;, &quot;Maven&quot;, &quot;Docker&quot;, &quot;ELK&quot;, &quot;Python&quot;, &quot;Php&quot;, &quot;JavaScript&quot;, &quot;VUE&quot; ] &#125;&#125;"},{"title":"友情链接","date":"2021-01-09T02:57:00.089Z","updated":"2021-01-09T02:57:00.089Z","comments":true,"path":"links/index.html","permalink":"https://sombreknight.gitee.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-09T03:00:41.011Z","updated":"2021-01-09T03:00:41.011Z","comments":false,"path":"categories/index.html","permalink":"https://sombreknight.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"项目","date":"2021-01-09T06:50:06.768Z","updated":"2021-01-09T06:50:06.760Z","comments":false,"path":"repository/index.html","permalink":"https://sombreknight.gitee.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-09T02:59:59.946Z","updated":"2021-01-09T02:59:59.946Z","comments":false,"path":"tags/index.html","permalink":"https://sombreknight.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《高并发红包炸弹项目性能优化》系列二：方案设计","slug":"0z9h4N46Yu0gPPfg","date":"2021-01-14T01:52:38.000Z","updated":"2021-01-14T01:52:05.000Z","comments":true,"path":"2021/01/14/0z9h4N46Yu0gPPfg/","link":"","permalink":"https://sombreknight.gitee.io/2021/01/14/0z9h4N46Yu0gPPfg/","excerpt":"","text":"一、开端​ 在上一篇文章《高并发红包炸弹项目性能优化》系列一：项目介绍 中，我介绍了下该红包项目的需求流程，以及一些此项目会涉及到的难点。这一篇文章，主要介绍针对此红包炸弹需求，我们的方案是如何设计的。由于项目是1.0版上线之后才交接到我手上的，因此方案并非我牵头设计的。但是对于别人的设计，我们还是可以怀着自己的思想去审视下，此方案的好坏，以及是否可以进一步优化。 二、方案设计前的思考​ 1. 首先我们对此项目有一个整体的交互模型，如下图所示, 管理员负责发红包，用户负责抢红包； 发红包最需要考虑的事情 发红包后用户抢到的子红包是提前生成好，还是用户抢的时候实时计算能抢多少？（离线计算还是实时计算？） 投放的红包炸弹在炸开前1分钟，如何通知到用户端，让用户端展示出红包炸弹倒计时？（推还是拉？） 怎样设计让一个红包拆分出的子红包能够具备一定的分布特性（如正态分布），使用户抢到的单个子红包金额在一个控制返回？（单个子红包不能太大，也不能太小） 抢红包最需要考虑的事情 如何应对瞬时高并发请求，怎样保护服务器，怎样保护DB？（羊毛党可能是为了薅羊毛，但黑客可能更想把你的服务器打挂） 如何防止超抢？即所有用户抢到的子红包之和应该小于等于红包总金额； 正常用户和黑客一起抢红包，黑客利用技术手段可以更及时的在红包炸弹爆开的一瞬间发起请求，如何识别非正常的请求？如何保证正常用户都能够公平的参与竞争？ 三、看看别人的方案设计1. 数据库表设计​ 如下图所示，是为满足红包炸弹相关需求所设计的表结构： 红包炸弹相关的有三张表： 红包表 ： 记录了谁在什么时间投放了一个红包炸弹,该红包炸弹的金额，可拆分的子红包数目，红包的炸开时间，红包的状态，以及记录了此红包什么时间被抢完; 子红包表: 记录了当前子红包属于哪个红包，当前子红包的金额，当前子红包的状态; 红包明细表：记录了哪个用户，在什么时间抢了一个怎样的子红包，明细表中冗余了子红包金额字段 支持红包炸弹的一张业务表： 报名记录表：记录了用户的报名信息和状态，相对于红包炸弹来讲，需要满足”用户报名成功才能抢红包“。 2. 消息通知流程整个红包炸弹需要进行消息通知的有这么几处地方： 后台创建了红包炸弹，用户端需要收到通知，然后在页面展示有一个红包炸弹即将在某个时间点炸开； 当距离红包炸弹炸开前1分钟时，用户端需要收到通知，然后在页面开始红包炸弹炸开的60秒倒计时； 当红包炸弹被管理员取消，或者红包炸开后15s用户没有抢完子红包，系统自动将红包置完成时，会通知用户端，红包已失效或者进入红包历史界面； 基于公司的中台IM系统（依赖第三方云服务即时通信），可以进行消息的及时下发，采用的是长链接的方式。 3. 前端请求限流当红包炸弹60秒倒计时完成，就可以点击红包云朵，进行抢红包了。这里为了限制请求，前端做的处理是，必须在发起一次抢红包接口返回后，才能发起下一次请求。目前用户端分别做了小程序版和H5版。很明显这种请求限流方式，在H5方案情况下，如果用户开多个浏览器，多个Tab窗口进行同时请求，是拦截不住的。这里我让前端做了一些优化，因为H5页面最终是嵌套在客户端内打开的，所以只要在判断当前环境是在客户端才能进行请求即可。单独抓包H5页面在浏览器是无法请求接口的。 4. 服务端核心接口逻辑实现申明：先申明下以下代码并非我写的，而是此红包项目交接到我手里时的代码。代码的问题多，后续我将会对这些代码进行针对性的问题优化，我们先只关注业务主流逻辑，我在其源码上加了必要的注释方便大家看懂，暂不要关心代码的严谨性和性能等问题 1）创建红包 创建红包接口逻辑大概如下： 12345678910111213141516@ApiOperation(value = &quot;后台创建红包炸弹&quot;)@PostMapping(&quot;/createForAuditor&quot;)@ValidateBodypublic RpcResponse&lt;String&gt; createForAuditor(@RequestBody CreateRedEnvelopeVO createRedEnvelopeVO)&#123; //省略一些基本条件校验逻辑 String redisLock = &quot;createForAuditor&quot; + inspectId; //获取分布式锁 redisLocker.lock(redisLock); //创建红包 redEnvelopeLogic.create(num, price, inspectId, TYPE_AUDITOR, startTime); //通过IM通知用户端，红包已经创建了，用户端收到通知后将会在页面显示一个红包炸弹将在什么时间开爆 redEnvelopeLogic.sendNoticeToIM(redEnvelopeDAO.queryLatestRedEnvelope(), CelebrationConstants.Hdf_Celebration_Bomb); //释放锁 redisLocker.unlock(redisLock); return RpcResponse.success(&quot;创建成功&quot;); &#125; 看下上面第10行里调用的创建红包的核心逻辑 123456789101112131415161718private void create4Auditor(Integer num, BigDecimal price, Long inspectId, HaoDate startTime) &#123; RedEnvelopeDO redEnvelopeDO = new RedEnvelopeDO(); redEnvelopeDO.setNum(num); redEnvelopeDO.setSourceId(inspectId); //红包的类型还有其他多种，这个类型代表时红包炸弹 redEnvelopeDO.setSourceType(RedEnvelopeConstants.TYPE_AUDITOR); redEnvelopeDO.setPrice(price); redEnvelopeDO.setStatus(RedEnvelopeConstants.STATUS_VALID); redEnvelopeDO.setTime(startTime); //保存红包到数据库 redEnvelopeDAO.save(redEnvelopeDO); //异步创建子红包 celebrationMqProcessor.sendCreateRedEnvelopeItem(redEnvelopeDO); //创建一个延迟MQ消息，在红包炸开后15s自动置红包炸弹完成 celebrationMqProcessor.sendAutoComplete(redEnvelopeDO); //创建一个延迟MQ消息，在红包炸开前1分钟，通知用户端，开始60s倒计时 celebrationMqProcessor.sendCountDownMsg(redEnvelopeDO); &#125; 可以看出，这里是提前创建好子红包的，我们来看下子红包是如何生成的 12345678910111213141516171819202122232425//createItems此方法已经是在MQ的消费者线程中执行的了public boolean createItems(RedEnvelopeMessage message)&#123; log.info(&quot;MQ Monitor createItems msg: &#123;&#125;&quot;, message); RedEnvelopeDO redEnvelopeDO = redEnvelopeDAO.findById(message.getRedEnvelopeId()); if(redEnvelopeDO == null)&#123; return true; &#125; //这里给价格乘以了100，看起来意思是把元/角/分的分单位整数化 Integer totalAmount = redEnvelopeDO.getPrice().intValue() * 100; Integer num = redEnvelopeDO.getNum(); //可以知道就是这个工具方法，把一个红包分成了指定份数的子红包 List&lt;Integer&gt; redEnvelopeList = RedEnvelopeUtil.divideRedEnvelope(totalAmount, num); redEnvelopeList.forEach(integer -&gt; &#123; RedEnvelopeItemDO redEnvelopeItemDO = new RedEnvelopeItemDO(); redEnvelopeItemDO.setRedEnvelopeId(redEnvelopeDO.getId()); redEnvelopeItemDO.setPrice(BigDecimal.valueOf((double) integer / 100)); redEnvelopeItemDO.setStatus(ITEM_STATUS_DOING); redEnvelopeItemDO.setDescription(&quot;红包炸弹&quot;); //子红包存库 redEnvelopeItemDAO.save(redEnvelopeItemDO); //把子红包的id Rpush到了redis的一个list redisClient.rpush(RED_ENVELOPE_ITEM_KEY + redEnvelopeDO.getId(), String.valueOf(redEnvelopeItemDO.getId())); &#125;); return true; &#125; 拆分红包为若干子红包的工具方法逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 生成红包一次分配结果 * @param totalAmount 总红包量 * @param totalNum 总份数 * @return List&lt;Integer&gt; */public static List&lt;Integer&gt; divideRedEnvelope(Integer totalAmount, Integer totalNum) &#123; //这个sendedAmount变量原作者应该是想表达，已经生成的红包消耗了多少钱了 Integer sendedAmount = 0; //这个sendedNum变量原作者应该是想表达，已经生产几个红包了 Integer sendedNum = 0; //这里min应该代表一个子红包最低应该是平均子红包金额的十分之一 int min = (totalAmount / totalNum ) / 10; //rdMin代表红包最低的真实价格，如果算出来min==0了，最少也要为1，此时单位应该是分，即子红包最小1分钱 Integer rdMin = min == 0 ? 1 : min; //rdMax代表子红包最大为平均值的2倍 Integer rdMax = (totalAmount / totalNum * 2); List&lt;Integer&gt; redEnvelope = new ArrayList&lt;&gt;(); while (sendedNum &lt; totalNum) &#123; //循环的计算每个子红包的价格，子红包价格区间在【1分，2倍平均红包的价格】 Integer bonus = randomOneRedEnvelope(totalAmount, totalNum, sendedAmount, sendedNum, rdMin, rdMax); redEnvelope.add(bonus); sendedNum++; sendedAmount += bonus; &#125; //返回由计算出来的子红包金额组成的List return redEnvelope;&#125;/** * 随机分配第n个红包 * @param totalAmount 总红包量 * @param totalNum 总份数 * @param sendedAmount 已发送红包量 * @param sendedNum 已发送份数 * @param rdMin 随机下限 * @param rdMax 随机上限 * @return Integer */private static Integer randomOneRedEnvelope(Integer totalAmount, Integer totalNum, Integer sendedAmount, Integer sendedNum, Integer rdMin, Integer rdMax) &#123; Integer boundMin = Math.max((totalAmount - sendedAmount - (totalNum - sendedNum - 1) * rdMax), rdMin); Integer boundMax = Math.min((totalAmount - sendedAmount - (totalNum - sendedNum - 1) * rdMin), rdMax); return getRandomVal(boundMin, boundMax);&#125;/** * 返回min~max区间内随机数，含min和max * @param min * @param max * @return Integer */private static int getRandomVal(int min, int max) &#123; return rand.nextInt(max - min + 1) + min;&#125; 2）抢红包 抢红包主接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106@GetMapping(&quot;/grabRedEnvelopes&quot;) @ApiOperation(value = &quot;抢红包接口&quot;, notes = &quot;userId 用户Id | redEnvelopeId：红包id&quot;) public RpcResponse&lt;GrabRedEnvelopeInfoVO&gt; grabRedEnvelopes(@RequestParam Long userId, @RequestParam Long redEnvelopeId)&#123; //空参校验 if(!ObjectUtils.allNotNull(userId, redEnvelopeId))&#123; return RpcResponse.error(ErrorCode.PARAMS_EXCEPTION); &#125; //校验红包是否存在，公司的当前基础服务框架中，DAO查询的findById方法会查询实体缓存 //实体缓存存放于redis中，如果实体缓存失效了，会去查询MySQL集群中的主库 RedEnvelopeDO redEnvelopeDO = redEnvelopeDAO.findById(redEnvelopeId); if(null == redEnvelopeDO)&#123; return RpcResponse.error(ErrorCode.PARAMS_EXCEPTION); &#125; //校验是否红包还没开爆，还没开爆就进来抢红包的，肯定要拦截 if(HaoDate.currentTimeSecond() - redEnvelopeDO.getTime().getTimeSecond() &lt; 0)&#123; return RpcResponse.error(ErrorCode.RED_NO_BEGAIN); &#125; //判断红包是否已经被取消了，如果已经取消了，也是抢不了的 if(ObjectUtils.notEqual(STATUS_VALID,redEnvelopeDO.getStatus()))&#123; return RpcResponse.error(ErrorCode.RED_BE_OVER); &#125; //构造结构返回的VO，gain字段表示是否抢到了红包 GrabRedEnvelopeInfoVO grabRedEnvelopeInfoVO = GrabRedEnvelopeInfoVO.builder().gain(false).userId(userId).build(); //获取分布式锁 String lockName = &quot;celebration_&quot; + userId; //这里用了tryLock，本质上是一个带超时返回的自旋锁 boolean isUserLock = redisLocker.tryLock(lockName, 5, 5); if(!isUserLock)&#123; //超时都没拿到锁，就返回请稍后重试 return RpcResponse.error(ErrorCode.NO_GET_LOCK_TIP); &#125; //判断有没有报名，这个getApplyUserByUserId接口逻辑是查询报名表，是否有报名成功的记录，此接口没有做缓存 ApplyUserDO applyUserDO = applyUserLogic.getApplyUserByUserId(userId); if(null == applyUserDO) &#123; //提示没报名，释放锁 grabRedEnvelopeInfoVO.setType(NO_SIGN_UP.getType()); redisLocker.unlock(lockName); return RpcResponse.success(grabRedEnvelopeInfoVO); &#125; //判断是否已经抢过当前红包了，这里Dao层查询了红包明细表，但是红包明细表中没有红包id，只有子红包id //所以这里连表查询了，这个dao方法一会儿放在下面的代码块中 Long redEnvelopeRefId = redEnvelopeRefDAO.getRedEnvelopeRef(redEnvelopeId, userId); if(null != redEnvelopeRefId)&#123; //如果已经抢过此红包了，就提示已抢过并释放锁，接口返回 grabRedEnvelopeInfoVO.setType(ALREADY_GAIN.getType()); redisLocker.unlock(lockName); return RpcResponse.success(grabRedEnvelopeInfoVO); &#125; //判断一天内是否已经抢过三次 //这个dao查询方法一会儿也放在下面的代码块中 List&lt;RedEnvelopeRefDO&gt; redEnvelopeRefDOList = redEnvelopeRefDAO.getRedEnvelopeRefList(userId); if(redEnvelopeRefDOList.size() &gt;= overLimit)&#123; //如果已经抢过三次了，则提示您已经三连冠了，把机会让给别人吧。 grabRedEnvelopeInfoVO.setType(OVER_GAIN.getType()); //释放分布式锁 redisLocker.unlock(lockName); //接口返回 return RpcResponse.success(grabRedEnvelopeInfoVO); &#125; try &#123; //从redis中Lpop一个子红包id出来，这个是在创建子红包时Rpush进入这个list的 //这里进行了id转换，如果抛NumberFormatException异常了，则说明list中已经空了 //代表红包已经被抢完了，在catch中处理了抢完的逻辑 Long redEnvelopeItemId = Long.valueOf(redisClient.lpop(RED_ENVELOPE_ITEM_KEY + redEnvelopeDO.getId())); log.info(&quot;redis itemId:&#123;&#125;&quot;,redisClient.lrange(RED_ENVELOPE_ITEM_KEY + redEnvelopeDO.getId(), 0, -1).toString()); //这里llen查询了下redis中存放子红包id的list长度，如果空了，并且当前红包还没有置完成，就直接给红包置完成了 if(!ObjectUtils.notEqual(0L,redisClient.llen(RED_ENVELOPE_ITEM_KEY + redEnvelopeDO.getId())) &amp;&amp; HaoDate.isZeroTime(redEnvelopeDO.getCompleteTime()))&#123; redEnvelopeDO.setCompleteTime(new HaoDate()); redEnvelopeDAO.update(redEnvelopeDO); &#125; //这里根据拿到的子红包id查询子红包实体。findById会先查询实体缓存，没有就查主库 RedEnvelopeItemDO redEnvelopeItemDO = redEnvelopeItemDAO.findById(redEnvelopeItemId); //开启事务，创建红包明细，更新子红包状态为完成，代表已经抢成功了。这里居然没关心事务返回结果，后面也会优化处理 jdbcDAO.withTransaction(()-&gt;&#123; RedEnvelopeRefDO redEnvelopeRefDO = new RedEnvelopeRefDO(); redEnvelopeRefDO.setPrice(redEnvelopeItemDO.getPrice()); redEnvelopeRefDO.setType(TYPE_AUDITOR); redEnvelopeRefDO.setRedEnvelopeItemId(redEnvelopeItemDO.getId()); redEnvelopeRefDO.setApplyUserId(applyUserDO.getId()); redEnvelopeRefDO.setUserId(applyUserDO.getUserId()); redEnvelopeRefDAO.save(redEnvelopeRefDO); redEnvelopeItemDO.setStatus(ITEM_STATUS_DONE); redEnvelopeItemDAO.update(redEnvelopeItemDO); &#125;); //设置接口返回的VO中Gain为true，表示抢成功了 grabRedEnvelopeInfoVO.setGain(true); grabRedEnvelopeInfoVO.setType(GAIN.getType()); grabRedEnvelopeInfoVO.setPrice(redEnvelopeItemDO.getPrice()); &#125;catch (NumberFormatException e)&#123; //如果这里捕获到异常，说明从redis的list取空了，设置为抢失败 grabRedEnvelopeInfoVO.setType(NO_GAIN.getType()); //更新红包的完成时间 if(HaoDate.isZeroTime(redEnvelopeDO.getCompleteTime())) &#123; redEnvelopeDO.setCompleteTime(new HaoDate()); redEnvelopeDAO.update(redEnvelopeDO); &#125; //接口返回 return RpcResponse.success(grabRedEnvelopeInfoVO); &#125;finally &#123; //这里释放锁，但时就目前这个代码严谨程度上看，还真不一定能及时释放掉这个锁，后面会讲我是怎么优化的 redisLocker.unlock(lockName); &#125; //接口返回vo return RpcResponse.success(grabRedEnvelopeInfoVO); &#125; 上面第43行的dao查询方法getRedEnvelopeRef，具体实现如下 123456789101112public Long getRedEnvelopeRef(@NotNull Long redEnvelopeId, @NotNull Long userId)&#123; //看这个sql是要连接redenvelopes红包表、redenvelopeitems子红包表、redenveloperefs红包明细表三表连接查询当前用户是否已经抢过这个红包了 //这个sql过于复杂了，而且性能不高，连起码的limit 1都没有加上，后面讲如何优化掉这个多表查询 String sql = &quot;select c.id from redenvelopes a inner join redenvelopeitems b on a.id = b.redenvelopeid inner join &quot; + &quot;redenveloperefs c on b.id = c.redenvelopeitemid where c.userid = :userId and a.id = :redEnvelopeId &quot; + &quot;and b.status = :status and a.sourcetype = :sourceType&quot;; SqlParam sqlParam = SqlParam.create(&quot;userId&quot;, userId). add(&quot;redEnvelopeId&quot;, redEnvelopeId). add(&quot;status&quot;, ITEM_STATUS_DONE). add(&quot;sourceType&quot;, TYPE_AUDITOR); return jdbcDAO.findField(Long.class, sql, sqlParam); 上面第52行dao查询方法getRedEnvelopeRefList，具体实现如下 12345678910111213public List&lt;RedEnvelopeRefDO&gt; getRedEnvelopeRefList(@NotNull Long userId)&#123; //可以看出来就是查询了所有的这一天时间短内，这个用户抢了这类型的红包记录 //直接返回了明细的DO，这里最起码的优化返回主键id列表或者sql Count一下就可以了。当然还有更好的优化。 String whereSql = &quot;where userid = :userId and type =:type and ctime &gt;= :startTime and ctime &lt;= :endTime&quot;; HaoDate now = new HaoDate(); String startTime = now.dateString(); String endTime = now.offsetDay(1).dateString(); SqlParam sqlParam = SqlParam.create(&quot;userId&quot;, userId). add(&quot;type&quot;, TYPE_AUDITOR). add(&quot;startTime&quot;, startTime). add(&quot;endTime&quot;, endTime); return jdbcDAO.findList(RedEnvelopeRefDO.class, whereSql, sqlParam); &#125; 通过上面几段最核心的代码，大概能看出来这些问题了。 代码不规范，很多地方不关心返回值，理所应当的认为调用成功 逻辑不严谨，像使用分布锁的地方，加锁地方和最终try…finally…的代码短隔了很多中间逻辑，无法保证一定就能进入try代码块，更无法保证一定会释放锁了 性能问题很多，使用缓存的地方，除了公司dao层框架提供的实体缓存和分布式锁，就没有别的地方使用缓存了。大量的查询库表，甚至出现多表连接的复杂SQL。在应对抢红包这样大并发的情况下，显然是不够的。 安全性问题： 锁的力度小（锁用户），不同用户并发进来，不会上锁。无法很好做到限流 使用了t r yLock带超时的自旋锁，恶意攻击时，可能一个用户就把所有机器的线程打满了，服务就不能提供给其他人了 接口整体没有限流，不能做到削峰填谷，流量洪峰下，可能打挂服务，也可能打挂DB 框架的dao层查询实体缓存是OK的，但是不能解决缓存穿透的问题。恶意用户一直使用不存在的userId请求的话，会给DB造成很大的压力 还有更多的问题就不一一列举了，在后面的文章中，我将一步步的优化代码、优化前后端交互流程、使用一些限流/熔断/降级、压力测试等手段一步步将这个抢红包项目彻底优化，以能够应付各种高并发下的问题。 四、总结这里篇文章里，我对红包炸弹交接先的设计方案、核心实现等做了一些介绍，在后面的文章中我将正式开始一步步地去优化这个项目。","categories":[{"name":"高并发项目","slug":"高并发项目","permalink":"https://sombreknight.gitee.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/"},{"name":"系列文章","slug":"高并发项目/系列文章","permalink":"https://sombreknight.gitee.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"红包","slug":"红包","permalink":"https://sombreknight.gitee.io/tags/%E7%BA%A2%E5%8C%85/"},{"name":"高并发","slug":"高并发","permalink":"https://sombreknight.gitee.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"性能优化","slug":"性能优化","permalink":"https://sombreknight.gitee.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"《高并发红包炸弹项目性能优化》系列一：项目介绍","slug":"MRWloLteKJcf5Idr","date":"2021-01-13T15:06:44.000Z","updated":"2021-01-13T15:07:12.000Z","comments":true,"path":"2021/01/13/MRWloLteKJcf5Idr/","link":"","permalink":"https://sombreknight.gitee.io/2021/01/13/MRWloLteKJcf5Idr/","excerpt":"","text":"一、项目介绍​ 受疫情影响，公司打算在今年搞一次全国医生线上年会。而公司为了或是引流、或是给医生分福利，计划设计一个砸钱抢红包的环节。运气非常不错，虽然整体方案最初的设计不是我做的，但是最后此红包项目的性能优化却落到了我这里。平常的业务项目里，大多接触不到高并发场景，故借此机会，对此项目进行一个好好优化梳理，相信一定会对自己大有裨益的。 首先介绍下抢红包的流程，如下图所示： 首先是年会活动主会场界面，如下图一所示，右下角展示的就是红包炸弹，当有炸弹即将在1分钟后爆开时，就会进入此60秒倒计时。当倒计时完成时界面出现抢红包的云朵图案，如下图二所示。 当点击抢红包云朵图案时，有一下情况： 用户没有报名参加年会，是无法参与抢红包的，会提示还没报名，并引导用户去报名页面，如下图一所示； 用户点击云朵，但是没有抢到红包，提示手慢了，如下图二所示； 用户点击云朵，成功抢到了，点击开红包，查看红包明细，如下图三所示； 用户点击云朵，系统检测出来该用户今天已经成功抢到三次红包了，提示已经3连冠，把机会让给别人。如下图四所示。 用户点击云朵，系统检测出来该用户已经抢成功过了当前红包，直接进入红包明细，如下图五所示。 后台投放红包很简单，管理员可以在后台投放红包炸弹，指定什么时候炸开，投放的红包会分成多少份，总金额是多少。如下图所示： 产品的一些关键特殊的要求，汇总如下： 一个红包炸开了，最多抢15s，这个红包就会被自动置完成，用户不能再抢了 一个用户一天最多抢成功3个红包 一个红包，同一用户最多只能抢成功一次 管理员随时可以在后台取消红包 至此，相信大家对此项目已经有了一定的基本了解。我再附上一张流程图更好的说明整个流程。 二、难点分析这个项目是有一定难度的，具体难在哪儿，我个人的看法如下： 公司的医生用户基数大，年会报名人数预计在30万+，年会当晚会持续多轮红包炸弹轰炸，平均QPS约为在30w/15s = 2000，但是抢红包的这15s不可能每一秒钟都qps都是均衡的，预计峰值QPS可能达到30w/5s = 6000左右，也就是预计在红包炸弹炸开的前5sQPS应该是最高的时候。查阅资料 可知，如微博每天1亿多pv的系统一般也就1500QPS，5000QPS峰值。但是具体多少QPS跟业务强相关，只读接口读缓存，将压力给到缓存单机3000+没问题，写请求1000+也正常，也复杂些可能也就几百+QPS。 如此高的并发下，我们很容易在服务层面想到加机器，但是最应该保护的其实是DB。如果一个红包分成了1000个子红包，这意味着抢完这个红包最多要写库1000次。感觉写库的量并不大，但是要知道的是，这1000次写库非常集中，瞬时写库会给DB造成比较大的压力，可能导致并发下其他查询事务受到影响，甚至影响到其他业务。故我们需要对必要的接口进行流量控制以保证接口的吞吐量维持在一个较高的位置，但是又不会直接影响到服务性能。 并发下，如何保证不“超买”。其实就是发了1万元红包，不能因为并发原因，就让用户抢出去2万块钱了。底线就是，宁可让用户抢不到，也不能抢超了。 怎样避免羊毛党，恶意刷接口等操作造成公司利益受损？ 三、总结好了，到这里我们先对此项目有个整体上的感知即可。 抢红包面向医生群体，数量约30w+；抢红包需要先报名；一天最多抢成功三次；同一红包只能抢成功一次。 下一篇文章具体介绍下这个项目的数据库表设计，以及他们的接口代码实现。","categories":[{"name":"高并发项目","slug":"高并发项目","permalink":"https://sombreknight.gitee.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/"},{"name":"系列文章","slug":"高并发项目/系列文章","permalink":"https://sombreknight.gitee.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"红包","slug":"红包","permalink":"https://sombreknight.gitee.io/tags/%E7%BA%A2%E5%8C%85/"},{"name":"高并发","slug":"高并发","permalink":"https://sombreknight.gitee.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"性能优化","slug":"性能优化","permalink":"https://sombreknight.gitee.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"博客计划","slug":"f2hoimvLZitLtDEL","date":"2021-01-10T05:26:20.000Z","updated":"2021-01-10T05:08:31.000Z","comments":true,"path":"2021/01/10/f2hoimvLZitLtDEL/","link":"","permalink":"https://sombreknight.gitee.io/2021/01/10/f2hoimvLZitLtDEL/","excerpt":"","text":"基础系列 数据结构之树系列 算法系列（贪心、回溯、动态规划） 操作系统系列（操作系统基础、UNIX基础） 计算机网络系列（IP协议、TCP协议、HTTP协议） Java系列 Java语言基础 Java集合框架（包含并发集合框架） Java多线程与高并发（锁、AQS、阻塞队列等） JVM系列（对象头、GC、JVM调优） Web框架系列 Spring框架（IOC、AOP、事务） SpringMVC框架（请求分发流程） SpringBoot(自动配置原理) SpringCloud系列 Eureka Ribbon OpenFeign Hystrix GateWay SpringCloud Alibaba系列 Nacos Sentinel Dubbo Seata 数据库系列 MySQL（SQL优化、锁、底层索引原理、分库分表、高可用） MongoDB ElasticSearch 中间件系列 Redis（数据结构、缓存/分布式锁/限流器等应用、缓存穿透/击穿/雪崩概念和解决方案、日志、主从/哨兵/集群） Zookeeper(基本使用、ZAB协议基本原理、高可用方案) RabbitMQ(基本概念和使用、高可用方案) Kafka（基本概念和使用、高可用方案） 软件工程系列 设计模式（结合Spring框架中的案例） 代码整洁之道 重构 领域对象模型 开源项目系列 手写Spring框架 基于RestTemplate封装一个Rpc框架，且支持全链路监控、支持限流/熔断/降级、支持同步/异步调用 基于JdbcTemplate封装一个Dao框架，支持乐观锁、支持单机一级和Redis二级实体缓存","categories":[{"name":"博客计划","slug":"博客计划","permalink":"https://sombreknight.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"博客计划","slug":"博客计划","permalink":"https://sombreknight.gitee.io/tags/%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/"}]}],"categories":[{"name":"高并发项目","slug":"高并发项目","permalink":"https://sombreknight.gitee.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/"},{"name":"系列文章","slug":"高并发项目/系列文章","permalink":"https://sombreknight.gitee.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"name":"博客计划","slug":"博客计划","permalink":"https://sombreknight.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"红包","slug":"红包","permalink":"https://sombreknight.gitee.io/tags/%E7%BA%A2%E5%8C%85/"},{"name":"高并发","slug":"高并发","permalink":"https://sombreknight.gitee.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"性能优化","slug":"性能优化","permalink":"https://sombreknight.gitee.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"博客计划","slug":"博客计划","permalink":"https://sombreknight.gitee.io/tags/%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/"}]}