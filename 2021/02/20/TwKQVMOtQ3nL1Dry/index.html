<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>Java虚拟机的体系结构---运行时数据区 | 张晨曦的博客</title><meta name="description" content="官方文档：https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;specs&#x2F;jvms&#x2F;se8&#x2F;html&#x2F;jvms-2.html  一、宏观角度 Java虚拟机规范中对于虚拟机结构的描述大概分为以下几个方面：  关于class文件格式(The class file format) 数据类型（Data Type） 原始类型和值（Primitive Types and Values） 参考类型"><meta property="og:type" content="article"><meta property="og:title" content="Java虚拟机的体系结构---运行时数据区"><meta property="og:url" content="https://sombreknight.gitee.io/2021/02/20/TwKQVMOtQ3nL1Dry/index.html"><meta property="og:site_name" content="张晨曦的博客"><meta property="og:description" content="官方文档：https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;specs&#x2F;jvms&#x2F;se8&#x2F;html&#x2F;jvms-2.html  一、宏观角度 Java虚拟机规范中对于虚拟机结构的描述大概分为以下几个方面：  关于class文件格式(The class file format) 数据类型（Data Type） 原始类型和值（Primitive Types and Values） 参考类型"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://sombreknight.gitee.io/2021/02/20/TwKQVMOtQ3nL1Dry/image-20210220154923409.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/02/20/TwKQVMOtQ3nL1Dry/image-20210220155858053.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/02/20/TwKQVMOtQ3nL1Dry/image-20210220160037168.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/02/20/TwKQVMOtQ3nL1Dry/image-20210220160054581.png"><meta property="article:published_time" content="2021-02-20T07:44:10.000Z"><meta property="article:modified_time" content="2021-02-20T07:44:15.000Z"><meta property="article:author" content="张晨曦"><meta property="article:tag" content="Java"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://sombreknight.gitee.io/2021/02/20/TwKQVMOtQ3nL1Dry/image-20210220154923409.png"><link rel="canonical" href="https://sombreknight.gitee.io/2021/02/20/TwKQVMOtQ3nL1Dry/index.html"><link rel="alternate" href="/atom.xml" title="张晨曦的博客" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/SombreKnight" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">张晨曦</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Java工程师</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Chengdu, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/SombreKnight" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/SombreKnight" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>寄言持重者，微物莫全轻!</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/Java/">Java</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/">系列文章</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/">高并发项目</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/">系列文章</a><span class="category-list-count">3</span></li></ul></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IP%E5%8D%8F%E8%AE%AE/" rel="tag">IP协议</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WireShark/" rel="tag">WireShark</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%93%E5%8C%85/" rel="tag">抓包</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%A2%E5%8C%85/" rel="tag">红包</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a><span class="tag-list-count">4</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/IP%E5%8D%8F%E8%AE%AE/" style="font-size:13px">IP协议</a> <a href="/tags/JVM/" style="font-size:13px">JVM</a> <a href="/tags/Java/" style="font-size:13.33px">Java</a> <a href="/tags/RabbitMQ/" style="font-size:13px">RabbitMQ</a> <a href="/tags/Redis/" style="font-size:13.33px">Redis</a> <a href="/tags/Spring/" style="font-size:13px">Spring</a> <a href="/tags/WireShark/" style="font-size:13px">WireShark</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size:13.67px">中间件</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size:14px">性能优化</a> <a href="/tags/%E6%8A%93%E5%8C%85/" style="font-size:13px">抓包</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size:13px">框架</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size:13px">消息队列</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size:13px">源码分析</a> <a href="/tags/%E7%BA%A2%E5%8C%85/" style="font-size:13.67px">红包</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size:13px">网络</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size:14px">高并发</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">5</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></p><p class="item-title"><a href="/2021/05/13/ijloSoUgFmCTSagt/" class="title">基于WireShark进行TCP协议分析</a></p><p class="item-date"><time datetime="2021-05-13T03:02:59.000Z" itemprop="datePublished">2021-05-13</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></p><p class="item-title"><a href="/2021/05/13/Ucdi7U14vry2KtO8/" class="title">基于WireShark抓包分析IP协议</a></p><p class="item-date"><time datetime="2021-05-13T03:02:53.000Z" itemprop="datePublished">2021-05-13</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Java/">Java</a></p><p class="item-title"><a href="/2021/04/19/2VtWIcgxfEv5oIRA/" class="title">优化高并发下获取系统当前时间毫秒数性能问题</a></p><p class="item-date"><time datetime="2021-04-19T00:35:14.000Z" itemprop="datePublished">2021-04-19</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Spring/">Spring</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Spring/Java/">Java</a></p><p class="item-title"><a href="/2021/03/21/qDf9nxMp5VywgXFc/" class="title">Spring 框架源码分析</a></p><p class="item-date"><time datetime="2021-03-21T07:31:55.000Z" itemprop="datePublished">2021-03-21</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></p><p class="item-title"><a href="/2021/02/25/WNC8rxhCVjxb8IWX/" class="title">全方位总结中间件之RabbitMQ</a></p><p class="item-date"><time datetime="2021-02-25T02:18:38.000Z" itemprop="datePublished">2021-02-25</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-TwKQVMOtQ3nL1Dry" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">Java虚拟机的体系结构---运行时数据区</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2021/02/20/TwKQVMOtQ3nL1Dry/" class="article-date"><time datetime="2021-02-20T07:44:10.000Z" itemprop="datePublished">2021-02-20</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/JVM/" rel="tag">JVM</a>, <a class="article-tag-link-link" href="/tags/Java/" rel="tag">Java</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/02/20/TwKQVMOtQ3nL1Dry/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 4.9k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 20(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><blockquote><p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html</a></p></blockquote><h2 id="一、宏观角度"><a href="#一、宏观角度" class="headerlink" title="一、宏观角度"></a>一、宏观角度</h2><p>Java虚拟机规范中对于虚拟机结构的描述大概分为以下几个方面：</p><ol><li>关于class文件格式(The class file format)</li><li>数据类型（Data Type）</li><li>原始类型和值（Primitive Types and Values）</li><li>参考类型和值（Reference Types and Values）</li><li>运行时数据区（Run-Time Data Areas）</li><li>帧（Frames）</li><li>对象的表示（Representation of Objects）</li><li>浮点运算（ Floating-Point Arithmetic）</li><li>特殊方法（Special Methods）</li><li>异常（Exception）</li><li>指令集概览（Instruction Set Summary）</li><li>类库（Class Libraries）</li><li>公共设计与私有实现（Public Design, Private Implementation）</li></ol><p>故如果可以遵循这些Java虚拟机的规范去设计，就可以正确的实现一个执行JVM语系的语言的解释平台。这里只对比较关键的部分Java虚拟机规范进行深入学习，以提升自己的视野，从更底层的角度了解Java虚拟机的工作原理。</p><h2 id="二、运行时数据区"><a href="#二、运行时数据区" class="headerlink" title="二、运行时数据区"></a>二、运行时数据区</h2><p>关于Java虚拟机中的运行时数据区，规范中这样描述：</p><blockquote><p>The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits. Other data areas are per thread. Per-thread data areas are created when a thread is created and destroyed when the thread exits.</p></blockquote><p>翻译过来就是：</p><blockquote><p>Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。其中一些数据区域是在Java虚拟机启动时创建的，只有在Java虚拟机退出时才会被销毁。其他数据区域是每个线程的。每线程数据区域在创建线程时创建，在线程退出时销毁。</p></blockquote><p>至此，大概清楚了Java虚拟机对于程序执行期间所使用的运行时数据区大概是分成了两个部分：</p><ol><li>公共的运行时数据区：随虚拟机启动而创建，随虚拟机退出而销毁</li><li>每个线程所使用的运行时数据区：随线程创建时创建，随线程退出时而销毁</li></ol><p>继续深入，深入前先看下目录，对于运行时数据区，官方文档这样定义了目录：</p><img src="/2021/02/20/TwKQVMOtQ3nL1Dry/image-20210220154923409.png" alt="image-20210220154923409" style="zoom:50%"><p>所以我们现在大概知道了运行时数据区的组成：</p><h3 id="1-PC寄存器（program-counter-register-程序计数器）"><a href="#1-PC寄存器（program-counter-register-程序计数器）" class="headerlink" title="1. PC寄存器（program counter register 程序计数器）"></a>1. PC寄存器（program counter register 程序计数器）</h3><p>官方介绍：</p><blockquote><p>The Java Virtual Machine can support many threads of execution at once (JLS §17). Each Java Virtual Machine thread has its own <code>pc</code> (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">§2.6</a>) for that thread. If that method is not <code>native</code>, the <code>pc</code> register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is <code>native</code>, the value of the Java Virtual Machine’s <code>pc</code> register is undefined. The Java Virtual Machine’s <code>pc</code> register is wide enough to hold a <code>returnAddress</code> or a native pointer on the specific platform.</p></blockquote><p>翻译过来就是：</p><blockquote><p>Java虚拟机可以同时支持多个执行线程。每个Java虚拟机线程都有自己的pc（程序计数器）寄存器。在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法。如果该方法不是Native方法，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。如果线程当前执行的方法是Native方法，则Java虚拟机的pc寄存器的值是未定义的。Java虚拟机的pc寄存器足够宽，可以容纳特定平台上的返回地址或本机指针。</p></blockquote><p>总结： PC寄存器就是运行时数据区中生命周期与线程关联的部分。每个线程的PC寄存器上记录了正在执行的Java虚拟机指令地址，但如果当前线程执行的是Native方法，PC寄存器上的值就是未定义。</p><h3 id="2-Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#2-Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="2. Java虚拟机栈（Java Virtual Machine Stacks）"></a>2. Java虚拟机栈（Java Virtual Machine Stacks）</h3><p>官方介绍：</p><blockquote><p>Each Java Virtual Machine thread has a private <em>Java Virtual Machine stack</em>, created at the same time as the thread. A Java Virtual Machine stack stores frames (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">§2.6</a>). A Java Virtual Machine stack is analogous to the stack of a conventional language such as C: it holds local variables and partial results, and plays a part in method invocation and return. Because the Java Virtual Machine stack is never manipulated directly except to push and pop frames, frames may be heap allocated. The memory for a Java Virtual Machine stack does not need to be contiguous.</p><p>In the First Edition of <em>The Java® Virtual Machine Specification</em>, the Java Virtual Machine stack was known as the Java stack.</p><p>This specification permits Java Virtual Machine stacks either to be of a fixed size or to dynamically expand and contract as required by the computation. If the Java Virtual Machine stacks are of a fixed size, the size of each Java Virtual Machine stack may be chosen independently when that stack is created.</p><p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of Java Virtual Machine stacks, as well as, in the case of dynamically expanding or contracting Java Virtual Machine stacks, control over the maximum and minimum sizes.</p><p>The following exceptional conditions are associated with Java Virtual Machine stacks:</p><ul><li>If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a <code>StackOverflowError</code>.</li><li>If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li></ul></blockquote><p>翻译过来就是：</p><blockquote><p>每个Java虚拟机线程都有一个与线程同时创建的私有Java虚拟机栈。Java虚拟机栈存储“栈帧”。Java虚拟机栈类似于传统语言（如C）的堆栈：它保存局部变量和部分结果，并在方法调用和返回中起作用。因为除了推送和弹出帧之外，Java虚拟机栈从不被直接操作，所以帧可以被堆分配。Java虚拟机栈的内存不需要是连续的。</p><p>在Java虚拟机规范的第一版中，Java虚拟机栈被称为Java栈（Java Stack）。</p><p>这个规范允许Java虚拟机栈具有固定的大小，或者根据计算的需要动态地扩展和收缩。如果Java虚拟机栈的大小是固定的，则在创建该堆栈时，可以独立选择每个Java虚拟机堆栈的大小。</p><p>Java虚拟机实现可以向程序员或用户提供对Java虚拟机栈的初始大小的控制，以及在动态扩展或收缩Java虚拟机栈的情况下，控制最大和最小大小。</p><p>以下异常情况与Java虚拟机栈相关：</p><ol><li><p>如果线程中的计算需要比允许的更大的Java虚拟机栈，则Java虚拟机抛出stackoverflower。</p></li><li><p>如果可以动态扩展Java虚拟机栈，并且尝试扩展，但无法提供足够的内存来实现扩展，或者如果内存不足，无法为新线程创建初始Java虚拟机栈，则Java虚拟机将抛出OutOfMemoryError。</p></li></ol></blockquote><p>总结：Java虚拟机栈也是数据运行时数据区中与线程生命周期关联的部分。 Java虚拟机栈在第一版规范中也被叫做Java堆栈。 Java虚拟机栈的功能就是保存线程中的局部变了和部分结果，并且在方法调用和返回中起作用。Java虚拟机栈内存不需要是连续的。Java虚拟机栈可以设置固定大小，也可以动态扩展收缩。</p><h3 id="3-堆（Heap）"><a href="#3-堆（Heap）" class="headerlink" title="3. 堆（Heap）"></a>3. 堆（Heap）</h3><p>官方介绍：</p><blockquote><p>The Java Virtual Machine has a <em>heap</em> that is shared among all Java Virtual Machine threads. The heap is the run-time data area from which memory for all class instances and arrays is allocated.</p><p>The heap is created on virtual machine start-up. Heap storage for objects is reclaimed by an automatic storage management system (known as a <em>garbage collector</em>); objects are never explicitly deallocated. The Java Virtual Machine assumes no particular type of automatic storage management system, and the storage management technique may be chosen according to the implementor’s system requirements. The heap may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger heap becomes unnecessary. The memory for the heap does not need to be contiguous.</p><p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the heap, as well as, if the heap can be dynamically expanded or contracted, control over the maximum and minimum heap size.</p><p>The following exceptional condition is associated with the heap:</p><ul><li>If a computation requires more heap than can be made available by the automatic storage management system, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li></ul></blockquote><p>翻译过来就是：</p><blockquote><p>Java虚拟机有一个堆，在所有Java虚拟机线程之间共享。堆是运行时数据区域，从中为所有类实例和数组分配内存。</p><p>堆是在虚拟机启动时创建的。对象的堆存储由自动存储管理系统（称为垃圾回收器）回收；对象从不显式释放。Java虚拟机不假设特定类型的自动存储管理系统，存储管理技术可以根据实现者的系统需求进行选择。堆可以是固定大小的，也可以根据计算的需要进行扩展，如果不需要更大的堆，则可以收缩堆。堆的内存不需要是连续的。</p><p>Java虚拟机实现可以让程序员或用户控制堆的初始大小，如果堆可以动态扩展或收缩，还可以控制堆的最大和最小大小。</p><p>以下异常情况与堆关联：</p><p>如果计算需要的堆超过了自动存储管理系统所能提供的堆，Java虚拟机将抛出OutOfMemoryError。</p></blockquote><p>总结：Java虚拟机中的堆是运行时数据区中的公共部分，生命周期与虚拟机绑定，所有的线程可共享。主要功能就是为所有的类实例和数组分配内存。垃圾回收针对的就是这个堆内存区域。堆的大小可以是固定的，也可以动态扩展收缩。Java虚拟机不设定限制垃圾回收器，使用者可以自己根据实际的系统需求选择使用哪些垃圾回收器。</p><h3 id="4-方法区（Method-Area）"><a href="#4-方法区（Method-Area）" class="headerlink" title="4. 方法区（Method Area）"></a>4. 方法区（Method Area）</h3><p>官方介绍：</p><blockquote><p>The Java Virtual Machine has a <em>method area</em> that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the “text” segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9">§2.9</a>) used in class and instance initialization and interface initialization.</p><p>The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.</p><p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the method area, as well as, in the case of a varying-size method area, control over the maximum and minimum method area size.</p><p>The following exceptional condition is associated with the method area:</p><ul><li>If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li></ul></blockquote><p>翻译过来就是：</p><blockquote><p>Java虚拟机有一个在所有Java虚拟机线程之间共享的方法区域。方法区类似于常规语言编译代码的存储区，或类似于操作系统进程中的“文本”段。它存储每个类的结构，如<strong>运行时常量池</strong>、<strong>字段</strong>和<strong>方法数据</strong>，以及<strong>方法和构造函数的代码</strong>，包括类和实例初始化以及接口初始化中使用的特殊方法。</p><p>方法区域是在虚拟机启动时创建的。尽管<strong>方法区域在逻辑上是堆的一部分</strong>，<strong>但简单的实现可能选择不进行垃圾收集或压缩</strong>。此规范不要求方法区域的位置或用于管理已编译代码的策略。方法区域可以是固定大小的，或者可以根据计算的需要进行扩展，并且可以在不需要更大的方法区域时收缩。方法区域的内存不需要是连续的。</p><p>Java虚拟机实现可以提供程序员或用户对方法区域的初始大小的控制，以及在大小不同的方法区域的情况下，控制最大和最小方法区域大小。</p><p>以下异常情况与方法区域有关：</p><p>如果方法区域中的内存无法用于满足分配请求，Java虚拟机将抛出OutOfMemoryError。</p></blockquote><p>总结：方法区是运行时数据区中的公共部分，生命周期与虚拟机绑定，所有线程可共享。其实方法区只是一个逻辑概念，本质上方法区就是堆的一部分。但是因为方法区存储的通常都是常量、字段、方法数据、代码文本等，所以可以不进行垃圾回收，故Java虚拟机规范单独把方法区拆出来作为运行时数据区的一部分。方法区的内存不需要是连续的，方法区的大小也可以由用户自行设定。</p><h3 id="5-运行时常量池（Run-Time-Constant-Pool）"><a href="#5-运行时常量池（Run-Time-Constant-Pool）" class="headerlink" title="5. 运行时常量池（Run-Time Constant Pool）"></a>5. 运行时常量池（Run-Time Constant Pool）</h3><p>官方文档：</p><blockquote><p>A <em>run-time constant pool</em> is a per-class or per-interface run-time representation of the <code>constant_pool</code> table in a <code>class</code> file (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">§4.4</a>). It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at run-time. The run-time constant pool serves a function similar to that of a symbol table for a conventional programming language, although it contains a wider range of data than a typical symbol table.</p><p>Each run-time constant pool is allocated from the Java Virtual Machine’s method area (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">§2.5.4</a>). The run-time constant pool for a class or interface is constructed when the class or interface is created (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">§5.3</a>) by the Java Virtual Machine.</p><p>The following exceptional condition is associated with the construction of the run-time constant pool for a class or interface:</p><ul><li>When creating a class or interface, if the construction of the run-time constant pool requires more memory than can be made available in the method area of the Java Virtual Machine, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li></ul><p>See <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html">§5 (<em>Loading, Linking, and Initializing</em>)</a> for information about the construction of the run-time constant pool.</p></blockquote><p>翻译过来就是：</p><blockquote><p>运行时常量池是类文件中常量池表的每个类或每个接口的运行时表示。它包含几种常量，从编译时已知的数字字面值到必须在运行时解析的方法和字段引用。运行时常量池的功能类似于传统编程语言的符号表，尽管它包含的数据范围比典型的符号表更广。</p><p><strong>每个运行时常量池都是从Java虚拟机的方法区域分配的</strong>。类或接口的运行时常量池是在Java虚拟机创建类或接口时构造的。</p><p>以下异常情况与类或接口的运行时常量池的构造相关：</p><p>在创建类或接口时，如果构建运行时常量池所需的内存超过了Java虚拟机的方法区域中可用的内存，则Java虚拟机将抛出OutOfMemoryError。</p></blockquote><p>总结：运行时常量池属于方法区，方法区数据堆，所以运行时常量池同方法区一样，也是一个逻辑概念，同样也是运行时数据区中的公共部分，与虚拟机生命周期绑定，所有线程共享。</p><h3 id="6-本地方法栈（Native-Method-Stacks）"><a href="#6-本地方法栈（Native-Method-Stacks）" class="headerlink" title="6. 本地方法栈（Native Method Stacks）"></a>6. 本地方法栈（Native Method Stacks）</h3><p>官方文档：</p><blockquote><p>An implementation of the Java Virtual Machine may use conventional stacks, colloquially called “C stacks,” to support <code>native</code> methods (methods written in a language other than the Java programming language). Native method stacks may also be used by the implementation of an interpreter for the Java Virtual Machine’s instruction set in a language such as C. Java Virtual Machine implementations that cannot load <code>native</code> methods and that do not themselves rely on conventional stacks need not supply native method stacks. If supplied, native method stacks are typically allocated per thread when each thread is created.</p><p>This specification permits native method stacks either to be of a fixed size or to dynamically expand and contract as required by the computation. If the native method stacks are of a fixed size, the size of each native method stack may be chosen independently when that stack is created.</p><p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the native method stacks, as well as, in the case of varying-size native method stacks, control over the maximum and minimum method stack sizes.</p><p>The following exceptional conditions are associated with native method stacks:</p><ul><li>If the computation in a thread requires a larger native method stack than is permitted, the Java Virtual Machine throws a <code>StackOverflowError</code>.</li><li>If native method stacks can be dynamically expanded and native method stack expansion is attempted but insufficient memory can be made available, or if insufficient memory can be made available to create the initial native method stack for a new thread, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li></ul></blockquote><p>翻译过来就是：</p><blockquote><p>Java虚拟机的实现可以使用传统的堆栈（俗称“C堆栈”）来支持Native方法（用Java编程语言以外的语言编写的方法）。Native方法栈也可用于实现Java虚拟机指令集的解释器，如C语言。不能加载本机方法且本身不依赖传统堆栈的Java虚拟机实现不需要提供本机方法栈。如果提供了本机方法堆栈，则通常在创建每个线程时为每个线程分配。</p><p>此规范允许本机方法堆栈可以是固定大小的，也可以根据计算的需要动态扩展和收缩。如果本机方法堆栈的大小是固定的，则在创建该堆栈时，可以独立选择每个本机方法堆栈的大小。</p><p>Java虚拟机实现可以为程序员或用户提供对本机方法堆栈初始大小的控制，以及在大小不同的本机方法堆栈的情况下，控制最大和最小方法堆栈大小。</p><p>以下异常情况与本机方法堆栈相关：</p><p>如果线程中的计算需要比允许的更大的本机方法堆栈，Java虚拟机将抛出StackOverflowError。</p><p>如果可以动态扩展本机方法堆栈并尝试扩展本机方法堆栈，但可用内存不足，或者如果可用内存不足，无法为新线程创建初始本机方法堆栈，则Java虚拟机将抛出OutOfMemoryError。</p></blockquote><p>总结：本地方法栈是用来支持native方法的，本地方法栈不是每个JVM实现所必须的（如果你设计的这个JVM实现根本就不需要执行native方法，那你就根本没必要设计这个本地方法栈），如果需要设计本地方法栈，则需要和线程生命周期绑定。这个本地方法栈是每个线程独享的，属于运行时数据区中非公共部分。</p><hr><p>根据官方虚拟机规范文档，可以得出运行时数据区的逻辑关系如下：</p><p><img src="/2021/02/20/TwKQVMOtQ3nL1Dry/image-20210220155858053.png" alt="image-20210220155858053"></p><p>补充： 实际上Hotspot虚拟机并没有区分Java虚拟机栈和本地方法栈，直接通用了。</p><h2 id="三、运行时数据区在Java6-7-8中的对比"><a href="#三、运行时数据区在Java6-7-8中的对比" class="headerlink" title="三、运行时数据区在Java6/7/8中的对比"></a>三、运行时数据区在Java6/7/8中的对比</h2><ol><li><p>在Java6的运行时数据区中，运行时常量池–（属于）-&gt; 方法区 –(属于)–&gt; 堆 ， 按照堆内存的分代划分，<strong>方法区属于永久代</strong>。直接内存用于NIO。<strong>Java堆用于存放对象的实例。而方法区存放类信息、运行时常量池、静态变量、字符串常量池。</strong></p></li><li><p>在Java7的运行时数据区中，运行时常量池–（属于）-&gt; 方法区 –(属于)–&gt; 堆 ， 按照堆内存的分代划分，<strong>方法区属于永久代</strong>。直接内存用于NIO。<strong>Java堆用于存放对象的实例、静态变量、字符串常量池。而方法区存放类信息、运行时常量池。</strong></p></li><li><p>在Java8的运行时数据区中，<strong>方法区直接放到了本地内存中的元空间中</strong>（Java8取消了永久代，新增了元空间，元空间直接放在本地内存中的）。所以此时本地内分为NIO所使用的直接内存和元空间。<strong>Java堆用于存放对象的实例、静态变量、字符串常量池。</strong>而<strong>方法区存放类信息、运行时常量池</strong>。</p></li></ol><p><img src="/2021/02/20/TwKQVMOtQ3nL1Dry/image-20210220160037168.png" alt="image-20210220160037168"></p><p><img src="/2021/02/20/TwKQVMOtQ3nL1Dry/image-20210220160054581.png" alt="image-20210220160054581"></p><center>以上图片来自于网络</center></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://sombreknight.gitee.io/2021/02/20/TwKQVMOtQ3nL1Dry/" title="Java虚拟机的体系结构---运行时数据区" target="_blank" rel="external">https://sombreknight.gitee.io/2021/02/20/TwKQVMOtQ3nL1Dry/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/SombreKnight" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/SombreKnight" target="_blank"><span class="text-dark">张晨曦</span><small class="ml-1x">Java工程师</small></a></h3><div>业精于勤，荒于嬉！</div></div></figure></div></div></div></article><section id="comments"></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2021/02/25/WNC8rxhCVjxb8IWX/" title="全方位总结中间件之RabbitMQ"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2021/01/23/TvwqUdDOBHHrMjB3/" title="《中间件之Redis》系列一：基础总结"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button><div class="bar-right"></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>感谢您的支持，我会继续努力的!</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/SombreKnight" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/SombreKnight" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2021 张晨曦<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script><script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"a5da84bef780e059a1e8",clientSecret:"f9dcc6152b0022fde05eb1dc81fb832311b62fb4",repo:"blog-comments",owner:"SombreKnight",admin:["SombreKnight"],id:md5(location.pathname),distractionFreeMode:!0});gitalk.render("comments")</script></body></html>