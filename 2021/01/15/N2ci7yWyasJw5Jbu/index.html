<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>《高并发红包炸弹项目性能优化》系列三：接口性能优化 | 张晨曦的博客</title><meta name="description" content="一、开始​    在上一篇文章《高并发红包炸弹项目性能优化》系列二：方案设计 中，我具体介绍了下该红包炸弹需求的实现方案，包括数据库表的设计、前端的限流请求措施、服务端关键接口的代码实现。在这一篇博客中，我将从服务端接口代码优化开始，逐步展开对整个红包炸弹项目的优化历程。毕竟，最重要的还是核心的业务接口。接口写得性能够好了，就成功一半了。剩下的无非是采取一些常见的手段，进行二次优化而已。真正需要动"><meta property="og:type" content="article"><meta property="og:title" content="《高并发红包炸弹项目性能优化》系列三：接口性能优化"><meta property="og:url" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/index.html"><meta property="og:site_name" content="张晨曦的博客"><meta property="og:description" content="一、开始​    在上一篇文章《高并发红包炸弹项目性能优化》系列二：方案设计 中，我具体介绍了下该红包炸弹需求的实现方案，包括数据库表的设计、前端的限流请求措施、服务端关键接口的代码实现。在这一篇博客中，我将从服务端接口代码优化开始，逐步展开对整个红包炸弹项目的优化历程。毕竟，最重要的还是核心的业务接口。接口写得性能够好了，就成功一半了。剩下的无非是采取一些常见的手段，进行二次优化而已。真正需要动"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116143738416.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116152350191.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116152937652.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116152956577.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116155917787.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116204754728.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116235601835.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/image-20210117000316891.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/image-20210117000340251.png"><meta property="og:image" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/image-20210117000427294.png"><meta property="article:published_time" content="2021-01-15T12:27:03.000Z"><meta property="article:modified_time" content="2021-01-15T12:26:45.000Z"><meta property="article:author" content="张晨曦"><meta property="article:tag" content="红包"><meta property="article:tag" content="高并发"><meta property="article:tag" content="性能优化"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116143738416.png"><link rel="canonical" href="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/index.html"><link rel="alternate" href="/atom.xml" title="张晨曦的博客" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/SombreKnight" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">张晨曦</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Java工程师</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Chengdu, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/SombreKnight" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/SombreKnight" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>寄言持重者，微物莫全轻!</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/">博客计划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/">高并发项目</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/">系列文章</a><span class="category-list-count">3</span></li></ul></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/" rel="tag">博客计划</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%A2%E5%8C%85/" rel="tag">红包</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a><span class="tag-list-count">3</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/" style="font-size:13px">博客计划</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size:14px">性能优化</a> <a href="/tags/%E7%BA%A2%E5%8C%85/" style="font-size:14px">红包</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size:14px">高并发</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">4</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/">高并发项目</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/">系列文章</a></p><p class="item-title"><a href="/2021/01/15/N2ci7yWyasJw5Jbu/" class="title">《高并发红包炸弹项目性能优化》系列三：接口性能优化</a></p><p class="item-date"><time datetime="2021-01-15T12:27:03.000Z" itemprop="datePublished">2021-01-15</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/">高并发项目</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/">系列文章</a></p><p class="item-title"><a href="/2021/01/14/0z9h4N46Yu0gPPfg/" class="title">《高并发红包炸弹项目性能优化》系列二：方案设计</a></p><p class="item-date"><time datetime="2021-01-14T01:52:38.000Z" itemprop="datePublished">2021-01-14</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/">高并发项目</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/">系列文章</a></p><p class="item-title"><a href="/2021/01/13/MRWloLteKJcf5Idr/" class="title">《高并发红包炸弹项目性能优化》系列一：项目介绍</a></p><p class="item-date"><time datetime="2021-01-13T15:06:44.000Z" itemprop="datePublished">2021-01-13</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/">博客计划</a></p><p class="item-title"><a href="/2021/01/10/f2hoimvLZitLtDEL/" class="title">博客计划</a></p><p class="item-date"><time datetime="2021-01-10T05:26:20.000Z" itemprop="datePublished">2021-01-10</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-N2ci7yWyasJw5Jbu" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">《高并发红包炸弹项目性能优化》系列三：接口性能优化</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2021/01/15/N2ci7yWyasJw5Jbu/" class="article-date"><time datetime="2021-01-15T12:27:03.000Z" itemprop="datePublished">2021-01-15</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/">高并发项目</a>►<a class="article-category-link" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/">系列文章</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a>, <a class="article-tag-link-link" href="/tags/%E7%BA%A2%E5%8C%85/" rel="tag">红包</a>, <a class="article-tag-link-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/01/15/N2ci7yWyasJw5Jbu/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 6.2k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 22(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h2 id="一、开始"><a href="#一、开始" class="headerlink" title="一、开始"></a>一、开始</h2><p>​ 在上一篇文章<a href="/2021/01/14/0z9h4N46Yu0gPPfg/">《高并发红包炸弹项目性能优化》系列二：方案设计</a> 中，我具体介绍了下该红包炸弹需求的实现方案，包括数据库表的设计、前端的限流请求措施、服务端关键接口的代码实现。在这一篇博客中，我将从服务端接口代码优化开始，逐步展开对整个红包炸弹项目的优化历程。毕竟，最重要的还是核心的业务接口。接口写得性能够好了，就成功一半了。剩下的无非是采取一些常见的手段，进行二次优化而已。真正需要动刀子的，还是在业务接口上。</p><h2 id="二、接口优化原则"><a href="#二、接口优化原则" class="headerlink" title="二、接口优化原则"></a>二、接口优化原则</h2><p>​ 面对接口的性能优化，我这样思考：</p><p>​ 接口，做了什么事？无非就是读/写。所有的网络请求都是在读/写。那优化的最终目标是什么？</p><p>​ 答案就是：让单位时间能够支持“更多”的读/写请求！</p><p>​ 剩下的问题就很简单了，我们采取各个击破的办法。</p><ol><li>如何让读取更快</li><li>如何让写入更快</li></ol><p>接下来就这两点，我来谈谈自己的处理意见。</p><h3 id="1-如何让读取更快"><a href="#1-如何让读取更快" class="headerlink" title="1. 如何让读取更快"></a>1. 如何让读取更快</h3><ol><li>减少DB查询，能走缓存就一定要走缓存；特殊业务场景要，可以在硬件上加大投入，给Redis集群进行扩容什么的都是OK的；</li><li>既然要走缓存，一定要考虑到数据一致性、缓存穿透、缓存击穿、缓存雪崩这三个问题，既然要用缓存就一定要用好缓存；</li><li>实在要走库的查询，一定要注意查询性能。主要从以下两方面优化：<ol><li>建立好自己的业务数据表模型，该垂直拆表的地方就拆，该冗余字段的地方就冗余，尽量保证自己的业务接口使用简单SQL查询。当然不管拆表还是冗余都是有代价的，可能需要维护数据的一致性，可能需要开事务进行多表写入。具体问题具体分析。</li><li>一旦数据表一定，很难再做修改的情况下，那就要更多地在SQL优化上下功夫。一般建议SQL查询计划至少要达到<code>ref</code>级别，能到<code>const</code>级别那当然更好；</li></ol></li></ol><h3 id="2-如何让写入更快"><a href="#2-如何让写入更快" class="headerlink" title="2. 如何让写入更快"></a>2. 如何让写入更快</h3><ol><li>写入的话，能写缓存，当然不建议写库。但是对于缓存，要考虑的问题更多，选用哪种数据结构，怎样保证数据一致性，什么时候缓存落库，缓存淘汰策略是什么，还有不要造成大面积缓存失效导致的缓存雪崩;</li><li>直接写库的话，要考虑下是否要优化表结构，尽可能在设计的时候就考虑减少锁冲突，表设计时还可以考虑使用乐观锁，能不用事务就不用事务，可以考虑定时任务来兜底，也可以考虑走MQ进行异步写库；</li><li>要考虑数据所使用的事务隔离级别，隔离级别越高，并发性越低；如果根本不存在事务问题，不使用带事务支持的数据库引擎也OK；</li></ol><h3><a href="#" class="headerlink"></a></h3><h2 id="三、高并发下还需要考虑哪些优化"><a href="#三、高并发下还需要考虑哪些优化" class="headerlink" title="三、高并发下还需要考虑哪些优化"></a>三、高并发下还需要考虑哪些优化</h2><ol><li><p>如果用到了分布式锁，一定要保证锁的及时释放，锁不及时释放，反而可能导致接口的吞吐量降低；另外就是分布式锁的选型，一般有基于Redis、Zookeeper以及数据库实现这三种，一般来说Redis锁更适合高并发下使用，Redis实现分布式锁相对于ZK和数据库来说也更简单；</p></li><li><p>还需要再提下分布式锁的使用，在高并发下不推荐使用带有超时退出的自旋锁，因为线程自旋会加大CPU的使用负担，同时也会持续占用线程，如果有大量的线程自旋，会导致把机器上的最大线程数打满（这个机器的线程数在Linux上是可以配置的，但仍然有上线），如此一来服务就不能分配出可用的线程继续提供服务了，会直接导致高并发下接口的吞吐量降低；</p></li><li><p>线程池技术的使用。要注意线程池的参数配置、以及阻塞队列是否有界、容量最大为多少，避免高并发下造成OOM，另外还需要注意使用线程池时线程复用下会不会有内存泄漏的问题，在合理的节点进行内存释放；</p></li><li><p>接口限流。在不考虑实际业务场景时，限流根本目的就是就是为了保护DB，因为在大多数情况下，DB是公共资源，不能因为一个业务，就把整个公共资源搞挂吧；</p></li><li><p>优化代码逻辑。所谓条条大路通罗马，但是通往罗马所付出的代价却是不一样的。简单的说就是用更好的算法处理业务逻辑。更好的算法往往可以更快的处理完业务逻辑，占用更小的空间，更少的IO次数。面对高并发，我们有必要绞尽脑汁去思考更聪明的做法。</p></li></ol><p>OK，至此，我总结了一些自己对于优化接口性能这件事上的一些宏观上的认识。当然性能优化可以从各个角度入手，远远不止我提到的这些。对于性能优化，我们应该采用<code>贪心算法</code>的思想，在各个环节优化到最好，最后的整体性能一定不会低到哪儿去。接下来，我们就正式开始进行<code>红包炸弹</code>项目的关键接口性能优化工作。</p><h2 id="四、简单优化创建红包接口"><a href="#四、简单优化创建红包接口" class="headerlink" title="四、简单优化创建红包接口"></a>四、简单优化创建红包接口</h2><p>​ 在<a href="/2021/01/14/0z9h4N46Yu0gPPfg/">《高并发红包炸弹项目性能优化》系列二：方案设计</a> 我贴上了项目交接前红包炸弹的具体创建接口的实现代码。</p><p>这里我再次把红包炸弹的创建逻辑再次说明下，如下图中的表结构所示，创建红包炸弹其实就是在红包表中新增一条红包记录，以及新增与此红包记录所关联的”若干”条子红包记录。这里的“若干”就是红包表中的<code>num</code>字段所指定的数量。</p><p><img src="/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116143738416.png" alt="image-20210116143738416"></p><center>图1-红包炸弹的表设计</center><br><p>这里再补充一下需求，产品认为同一时间只能有一个正在进行中的红包。也就是说，如果在创建红包时还有处于未开抢的，或者正在被抢的红包，或者还没有置完成的红包，那么这时不能投放新的红包的。另外，投放红包只有管理员才可以进行操作。因为对于此接口我们并没有太多的并发度要求。我只要保证此接口可以逻辑正确、可靠的执行完成就OK了。</p><p><img src="/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116152350191.png" alt="image-20210116152350191"></p><center>图2-创建红包接口的优化前后diff截图</center><br><p>如上图2所示，是对创建接口的一些基本优化后的前后diff截图。</p><ol><li>在创建接口的入口处，添加了一处判断逻辑：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//爆炸时间必须至少在当前时间的1分钟后,这样才能做到爆炸前60s通知IM</span></span><br><span class="line">    <span class="keyword">if</span> (!startTime.after(<span class="keyword">new</span> HaoDate().offsetMinutes(<span class="number">1</span>)))&#123;</span><br><span class="line">        <span class="keyword">return</span> RpcResponse.error(ErrorCode.RED_ENVELOPE_TIME_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ 为什么加这么一个判断呢，因为按照需求，我们需要在爆炸前60s发送一个IM消息，通知前端开始进行红包炸弹的一分钟倒计时。如果在创建红包时所指定的红包炸弹炸开时间在将来的不到一分钟内。那么我们无法就无法满足需求了。即红包一创建，里炸开时间就已经小于60秒了，这种情况下进行红包60秒倒计时显然是不合适的。</p><ol start="2"><li>优化锁使用，这里应该明显是应该先获取锁，再判断是否还有进行中的红包。使用try…finally…保证锁最终会被释放。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HdfAssert.isTrue(redisLocker.lock(redisLock),ErrorCode.ACTION_FAST);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (redEnvelopeLogic.isExistDoingRedEnvelope())&#123;</span><br><span class="line">    <span class="keyword">return</span> RpcResponse.error(ErrorCode.EXIST_DOING_RED_ENVELOPE);</span><br><span class="line">  &#125;</span><br><span class="line">  redEnvelopeLogic.create(num, price, inspectId, TYPE_AUDITOR, startTime);</span><br><span class="line">  redEnvelopeLogic.sendNoticeToIM(redEnvelopeDAO.queryLatestRedEnvelope(), CelebrationConstants.Hdf_Celebration_Bomb);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  redisLocker.unlock(redisLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> RpcResponse.success(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外这里，为了防止MySQL的主从延迟导致调用上面的第3行<code>redEnvelopeLogic.isExistDoingRedEnvelope()</code>这个方法得到错误的结果，对于此查询强制走主库。</p><p><img src="/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116152937652.png" alt="image-20210116152937652"></p><p><img src="/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116152956577.png" alt="image-20210116152956577"></p><ol start="3"><li>深入优化创建红包逻辑，如下图3所示</li></ol><img src="/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116155917787.png" alt="image-20210116155917787"><center>图3-创建红包的核心逻辑修改后的diff</center><br><p>这里改动逻辑是：</p><ul><li><p>创建红包记录，要关注其返回值，确认创建成功了，才继续进行后续的创建子红包任务、创建自动完成延迟任务、创建倒计时延迟任务；</p></li><li><p>创建红包成功后，这里将红包id缓存了一份在Redis中。用于记录最新的正在进行中的红包id。这里缓存此id其实是为了后续优化用户端调用的接口查询，将在后续讲解到解决IM推送不及时的问题时提到其用途；</p></li><li><p>红包炸开后15秒自动完成以及红包炸开前1分钟倒计时，原本是使用延迟MQ实现，这里改使用<code>ScheduledThreadPoolExecutor</code>实现了。因为这个延迟MQ需要随机计算出一个从创建红包的时刻到目标时刻的延迟时间，每次创建都有可能产生一个延迟MQ队列，受限于公司的MQ架构延迟队列数量限制，此方法不可取。所以这里使用了<code>ScheduledThreadPoolExecutor</code>来实现。</p><p>具体封装如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> coreSize = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        scheduledThreadPoolExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(coreSize</span><br><span class="line">            , Executors.defaultThreadFactory()</span><br><span class="line">            , <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable runnable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time     秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delayCall</span><span class="params">(Runnable runnable, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        scheduledThreadPoolExecutor.schedule(runnable, time, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        scheduledThreadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在这个业务可以提前确认只会有<code>1分钟倒计时</code>和<code>15秒自动完成</code>这两个延迟任务，所以对于这个<code>ScheduledThreadPoolExecutor</code>的参数配置，并无太多考究。可以用即可。</p><p>但是<code>ScheduledThreadPoolExecutor</code>也存在一个严重的问题，那就是这不是一个分布式的调度器，也不具备持久化任务的能力，所以在服务重启等特殊情况下，延迟任务可能丢失。具体使用一定要看场景。</p><p>比如，在红包炸弹里，15s自动完成的延迟任务是这样使用<code>ScheduledThreadPoolExecutor</code>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAutoComplete</span><span class="params">(RedEnvelopeDO redEnvelopeDO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = HaoDate.currentTimeSecond();</span><br><span class="line">        <span class="keyword">long</span> delay = redEnvelopeDO.getTime().getTimeSecond() - now + Long.parseLong(cloudCountDown) + <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            delay = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RedEnvelopeMessage msg = <span class="keyword">new</span> RedEnvelopeMessage();</span><br><span class="line">        msg.setRedEnvelopeId(redEnvelopeDO.getId());</span><br><span class="line">        <span class="comment">//存redis标记，表示又一个异步任务待执行</span></span><br><span class="line">        redisClient.set(REDIS_KEY_TASK_WAITING_AUTO_COMPLETE_FLAG, redEnvelopeDO.getId().toString());</span><br><span class="line">        scheduledThreadPool.delayCall(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.autoComplete(msg);</span><br><span class="line">            <span class="comment">//清redis标记，表示该异步任务执行完成了</span></span><br><span class="line">            redisClient.delete(REDIS_KEY_TASK_WAITING_AUTO_COMPLETE_FLAG);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">//查询异步任务标记是否存在，存在说明上一次任务没有执行完，bean就被销毁了，重新拉起调度</span></span><br><span class="line">  String redEnvelopeIdStr = redisClient.get(REDIS_KEY_TASK_WAITING_AUTO_COMPLETE_FLAG);</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isNotEmpty(redEnvelopeIdStr) &amp;&amp; NumberUtils.isNumber(redEnvelopeIdStr)) &#123;</span><br><span class="line">    <span class="keyword">long</span> redEnvelopeId = Long.parseLong(redEnvelopeIdStr);</span><br><span class="line">    <span class="keyword">if</span> (redEnvelopeId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      RedEnvelopeDO redEnvelope = redEnvelopeDAO.findById(redEnvelopeId);</span><br><span class="line">      <span class="keyword">if</span> (Objects.nonNull(redEnvelope) &amp;&amp; redEnvelope.getCompleteTime().isZeroTime()) &#123;</span><br><span class="line">        <span class="comment">//需要重新拉起任务</span></span><br><span class="line">        <span class="keyword">this</span>.setAutoComplete(redEnvelope);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，在将延迟任务丢给<code>ScheduledThreadPoolExecutor</code>前，将红包id缓存到了用于表示未完成的任务标志redis key中，在延迟任务调度完成后，删除缓存key。这样在服务重启后，当bean被初始化时，回调到init方法，此时再次检查redis中是否还有记录有未完成的红包id。有的话，就让他重新进延迟。说到底，这是一个兜底的方案，因为真有高并发的抢红包状况发生的话，一定在红包炸开后很快就被抢完，用户的动作会主动触发置红包完成。</p></li></ul><ol start="4"><li><p>再回到图3中改动后的178行，看下创建子红包的改动：</p><p><img src="/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116204754728.png" alt="image-20210116204754728"></p><center>图4-子红包的创建与子红包缓存</center><br><p>如上图中的diff所示，主要改动的是关注了子红包创建的返回值，只有当子红包创建成功的时候，才会向Redis中维护子红包id的List进行Rpush。可以说这里非常重要，如果无法维护子红包和缓存中的子红包List的数据一致性，则可能出现以下两种情况：</p><ul><li>某一子红包写库成功了，但是写入redis的失败了：这种情况还好，因为抢红包不可能抢到没有写入库的子红包，不会出现超抢</li><li>某一子红包写库失败了，但是写入redis的成功了：这种情况就会出现问题，因为可能抢到的子红包id，在子红包表中并不存在，如果抢红包的接口逻辑不足够健壮，可能导致用户<code>虚抢一场</code></li></ul><p>最后，可能大家会发现，这里并没有使用事务来批量创建数据。原因是，这里可以不用考虑事务，因为创建丢失某个子红包也无伤大雅，顶多就是用户抢不到这个红包了，可以接受。</p></li></ol><h2 id="五、深入优化抢红包接口"><a href="#五、深入优化抢红包接口" class="headerlink" title="五、深入优化抢红包接口"></a>五、深入优化抢红包接口</h2><p>在第四节里，我简单介绍了下创建红包的接口做了哪些小优化，因为创建接口并不难，所以对此接口也没有太高的性能要求，只要保证接口是好使的，子红包缓存是可靠的即可。接下来的优化抢红包接口才是重头戏。</p><p><img src="/2021/01/15/N2ci7yWyasJw5Jbu/image-20210116235601835.png" alt="image-20210116235601835"></p><center>图5-创建红包后的存储模型</center><br><p>如上图5所示，在创建红包成功后，数据的存储模型应该是这样的。缓存中既存入了正在进行中的红包id，也存如了子红包的id所组成的List。</p><p>所以抢红包要做的事情很简单：</p><ol><li>基本的条件校验，不满足则不能抢</li><li>尝试从子红包id列表缓存中Lpop一个子红包id出来，如果pop不出来数据了，说明红包被抢完了</li><li>Lpop出有效的红包后，更新子红包状态，创建一条红包明细记录</li></ol><p>看下整体代码优化Diff如下：</p><p><img src="/2021/01/15/N2ci7yWyasJw5Jbu/image-20210117000316891.png" alt="image-20210117000316891"></p><p><img src="/2021/01/15/N2ci7yWyasJw5Jbu/image-20210117000340251.png" alt="image-20210117000340251"></p><p><img src="/2021/01/15/N2ci7yWyasJw5Jbu/image-20210117000427294.png" alt="image-20210117000427294"></p><p>这里具体说下在抢红包接口中都做了哪些优化：</p><ol><li><p>首先是在原来的基础校验逻辑上补充了判断，当红包已经完成后，就直接返回，不需要在走后续的代码逻辑了。这里需要说明的是原来的表结构对于状态位的设计是太合理的。红包的状态目前是需要根据<code>status</code>和<code>complete</code>这两个字段共同判断的，但是由于项目已上线，红包表并非只有红包炸弹这个模块在使用，无法更改了，只好对两个字段都进行考虑了；</p></li><li><p>然后是对于判断用户是否报名了，原来是直接sql查询报名表。现在在这个<code>applyUserLogic.getApplyUserByUserId(userId)</code>方法上维护了一层缓存，处理逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ApplyUserDO <span class="title">getApplyUserByUserId</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">        ApplyUserDO applyUser = <span class="keyword">null</span>;</span><br><span class="line">        String redisKey = CELEBRATION + GET_APPLY_USER_BY_USER_ID + userId;</span><br><span class="line">        String cache = cacheUtil.getCache(redisKey);</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(NULL,cache))&#123;</span><br><span class="line">            <span class="comment">//这里是刻意缓存了NULL，表示不用再次查库了，查库也是null，以防止恶意缓存穿透，从而保护DB</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(cache))&#123;</span><br><span class="line">            applyUser = JsonUtils.toObject(cache, ApplyUserDO.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(applyUser))&#123;</span><br><span class="line">            <span class="keyword">return</span> applyUser;</span><br><span class="line">        &#125;</span><br><span class="line">        applyUser = applyUserDAO.findApplyUserByUserIdAndStatus(userId, ApplyUserConstants.STATUS_DONE);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(applyUser))&#123;</span><br><span class="line">            <span class="comment">//随机缓存5到10分钟，防止缓存大面积失效导致缓存雪崩</span></span><br><span class="line">            cacheUtil.setCache(redisKey, JsonUtils.toJson(applyUser), (<span class="keyword">long</span>) RandomUtils.randomInt(MINUTE_5,MINUTE_10));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果不存在，缓存一个NULL，防止恶意的缓存穿透</span></span><br><span class="line">            cacheUtil.setCache(redisKey, NULL,(<span class="keyword">long</span>) RandomUtils.randomInt(MINUTE_5,MINUTE_10));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> applyUser;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上面的代码所示，这里编程式地维护了一层缓存，并且考虑到了缓存穿透和缓存雪崩。另外在新增报名记录、报名状态变更时对缓存进行了失效处理，这里就不贴代码了。</p></li><li><p>再往后面，原来通过sql查询，分别先后判断了此用户是否已经抢过当前红包了、一天内是否已经成功抢了三次红包。这里优化为一处缓存查询就可以了。如下面的代码所示，<code>getGrabSuccessEnvelopeIds</code>方法的作用就是获取此用户在今天所有抢到的红包id所组成的List。所以可以将代码逻辑优化为先判断是否超过次数，再判断是否已经抢过此红包。将两次sql查询，转换为一次Redis IO。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; grabSuccessEnvelopeIds = getGrabSuccessEnvelopeIds(userId);</span><br><span class="line">       <span class="comment">//判断是否超过次数</span></span><br><span class="line">       <span class="keyword">if</span> (grabSuccessEnvelopeIds.size() &gt;= overLimit)&#123;</span><br><span class="line">           grabRedEnvelopeInfoVO.setType(OVER_GAIN.getType());</span><br><span class="line">           <span class="keyword">return</span> RpcResponse.success(grabRedEnvelopeInfoVO);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//判断是否已经抢过红包，这里不可能进来昨天的红包id，前面就拦截了</span></span><br><span class="line">       <span class="keyword">if</span> (grabSuccessEnvelopeIds.contains(redEnvelopeId))&#123;</span><br><span class="line">           grabRedEnvelopeInfoVO.setType(ALREADY_GAIN.getType());</span><br><span class="line">           <span class="keyword">return</span> RpcResponse.success(grabRedEnvelopeInfoVO);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取今日已抢成功的红包id列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId 用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 已抢成功的红包id列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Long&gt; <span class="title">getGrabSuccessEnvelopeIds</span><span class="params">(<span class="keyword">long</span> userId)</span></span>&#123;</span><br><span class="line">        String todayDateString = <span class="keyword">new</span> HaoDate().dateString();</span><br><span class="line">        List&lt;String&gt; envelopeIdStrList = redisClient.lrange(ONE_DAY_GRAB + todayDateString + userId, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> envelopeIdStrList.stream().map(Long::parseLong).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是，这里没有用HASH来存储此缓存是因为目前公司的框架对于Redis提供的Hash相关的api实在难用之际，还不如使用List来实现。<code>getGrabSuccessEnvelopeIds</code>方法中使用了redis的LRANGE操作，这是一个时间复杂度为O(N)的操作，一般情况要慎用。但是这里这处缓存，我们明确可以知道list最大长度为3。因为一条最多能抢成功三次红包。所以LRANGE的时间复杂度对接口的影响可以忽略。</p></li><li><p>再往后，我优化了Redis锁的使用。</p><ul><li>首先是把原本的tryLock设定的5秒超时时间置0了。之所以这样做是因为，在当前这样的高并发需求下，我们需要接口能够处理更多的请求，但是机器可以开启的线程数是有上限的，所以我们不能让线程在获取分布式锁这件事情上自旋等待超时了，正确的做法应该是拿不到锁就立即返回，把线程资源释放出来给别的请求使用。</li><li>然后是调整了锁的位置。原来的锁位置台靠前了。获取锁后，还有各种条件判断，在返回语句中还要释放锁。万一中间某一步有异常抛出，这么操作的无法保证锁真的可以及时释放。分布式锁应该锁住的是最核心的需要处理并发的代码块。</li></ul></li><li><p>获取到锁后，在原先的实现中会先从redis中弹出子红包id，而后又llen查询了一遍子红包id缓存的List长度，如果为空的就将红包置完成。这里的实现又有两个问题被优化：</p><ol><li>尝试LPOP一个子红包id，原逻辑中通过try…catch…来区分是不是取到了非正常的子红包id，如果出现异常，则认为子红包已经抢完了。这里完全不需要这么搞，完全可以避免此处异常的判断。</li><li>主动LLEN查看子红包idList的长度，来置红包状态完成。这也是一个不必要且拉低接口性能的操作。首先完全可以由用户在LPOP为空时置完成，其次就又回到了LLEN的时间复杂度问题，List的长度越大，LLEN的性能越低，再List没有取空的时候，做这么多LLEN操作完全是在浪费时间。这一次IO完全是可以省去的。</li></ol><p>优化代码如下,只需要一次IO操作进行一个时间复杂度为O(1)的LPOP操作即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String redEnvelopeItemIdStr = redisClient.lpop(RED_ENVELOPE_ITEM_KEY + redEnvelopeDO.getId());</span><br><span class="line">            <span class="comment">//如果不是一个数字，说明取空了，置红包状态即可</span></span><br><span class="line">            <span class="keyword">if</span> (!NumberUtils.isNumber(redEnvelopeItemIdStr)) &#123;</span><br><span class="line">                setRedEnvelopeComplete(redEnvelopeId);</span><br><span class="line">                grabRedEnvelopeInfoVO.setType(NO_GAIN.getType());</span><br><span class="line">                <span class="comment">//将缓存中记录的正在进行的红包id值清0</span></span><br><span class="line">                redEnvelopeLogic.removeDoingRedEnvelopeIdCache();</span><br><span class="line">                <span class="keyword">return</span> RpcResponse.success(grabRedEnvelopeInfoVO);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li><li><p>再往后这一处优化，我觉得都不能算优化吧。应该是意识问题了，原逻辑这么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RedEnvelopeItemDO redEnvelopeItemDO = redEnvelopeItemDAO.findById(redEnvelopeItemId);</span><br><span class="line"><span class="comment">//这里都不需要对redEnvelopeItemDO判个空么？</span></span><br><span class="line">            jdbcDAO.withTransaction(()-&gt;&#123;</span><br><span class="line">               RedEnvelopeRefDO redEnvelopeRefDO = <span class="keyword">new</span> RedEnvelopeRefDO();</span><br><span class="line">                redEnvelopeRefDO.setPrice(redEnvelopeItemDO.getPrice());</span><br><span class="line">                redEnvelopeRefDO.setType(TYPE_AUDITOR);</span><br><span class="line">                redEnvelopeRefDO.setRedEnvelopeItemId(redEnvelopeItemDO.getId());</span><br><span class="line">                redEnvelopeRefDO.setApplyUserId(applyUserDO.getId());</span><br><span class="line">                redEnvelopeRefDO.setUserId(applyUserDO.getUserId());</span><br><span class="line">                redEnvelopeRefDAO.save(redEnvelopeRefDO);</span><br><span class="line">                redEnvelopeItemDO.setStatus(ITEM_STATUS_DONE);</span><br><span class="line">                redEnvelopeItemDAO.update(redEnvelopeItemDO);</span><br><span class="line">            &#125;);</span><br><span class="line">						grabRedEnvelopeInfoVO.setGain(<span class="keyword">true</span>);</span><br><span class="line">            grabRedEnvelopeInfoVO.setType(GAIN.getType());</span><br><span class="line">            grabRedEnvelopeInfoVO.setPrice(redEnvelopeItemDO.getPrice());</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.success(grabRedEnvelopeInfoVO);  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有什么问题，问题就出在存在多处不严谨：</p><ol><li>findById后返回的redEnvelopeItemDO对象竟然没判空。如果说创建红包时，能够确认存子红包到数据库成功后再Rpush到子红包id缓存List，我觉得都没有问题。问题就是，创建红包时，并没有关注新增子红包后的返回值就直接写Redis了。这种情况下，很有可能在redis中写入了一个不存在的红包id。</li><li>如果去除了一个不存在的红包id，好吧，也罢。事务中肯定会报NPE，事务一定会失败。但为何后续也不关注事务的返回结果就直接设置接口响应的VO，标记已经抢红包成功了，并返回了结果？？？这将会直接导致用户端展示为抢红包成功了，但根本看不到自己抢了多少钱…</li></ol><p>优化后如下，具体关键步骤逻辑如注释描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">RedEnvelopeItemDO redEnvelopeItemDO = redEnvelopeItemDAO.findById(Long.parseLong(redEnvelopeItemIdStr));</span><br><span class="line"><span class="comment">//先对redEnvelopeItemDO判空，不为空，说明子红包表才是真的存在这么一个红包</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(redEnvelopeItemDO)) &#123;</span><br><span class="line">                grabRedEnvelopeInfoVO.setType(NO_GAIN.getType());</span><br><span class="line">                <span class="keyword">return</span> RpcResponse.success(grabRedEnvelopeInfoVO);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//关注事务的返回结果</span></span><br><span class="line">            <span class="keyword">boolean</span> transaction = jdbcDAO.withTransaction(() -&gt; &#123;</span><br><span class="line">                RedEnvelopeRefDO redEnvelopeRefDO = <span class="keyword">new</span> RedEnvelopeRefDO();</span><br><span class="line">                redEnvelopeRefDO.setPrice(redEnvelopeItemDO.getPrice());</span><br><span class="line">                redEnvelopeRefDO.setType(TYPE_AUDITOR);</span><br><span class="line">                redEnvelopeRefDO.setRedEnvelopeItemId(redEnvelopeItemDO.getId());</span><br><span class="line">                redEnvelopeRefDO.setApplyUserId(applyUser.getId());</span><br><span class="line">                redEnvelopeRefDO.setUserId(applyUser.getUserId());</span><br><span class="line">                <span class="keyword">int</span> saveRes = redEnvelopeRefDAO.save(redEnvelopeRefDO);</span><br><span class="line">              <span class="comment">//保存完红包明细记录后，也要关注返回结果，如果不成功，需要主动抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (!Objects.equals(CONST_1, saveRes)) &#123;</span><br><span class="line">                    <span class="comment">//如果没保存ref成功,抛异常使事务失败</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;创建红包明细失败～&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                redEnvelopeItemDO.setStatus(ITEM_STATUS_DONE);</span><br><span class="line">                <span class="keyword">int</span> updateRes = redEnvelopeItemDAO.update(redEnvelopeItemDO);</span><br><span class="line">              <span class="comment">//更新子红包状态不成功，也需要主动抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (!Objects.equals(CONST_1, updateRes)) &#123;</span><br><span class="line">                    <span class="comment">//如果更新红包项状态失败，抛异常使事务失败</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;更新红包项状态失败～&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (!transaction) &#123;</span><br><span class="line">              <span class="comment">//事务失败了，那就是抢红包失败了，此时子红包缓存list中此id被消耗掉了也无所谓</span></span><br><span class="line">                grabRedEnvelopeInfoVO.setType(NO_GAIN.getType());</span><br><span class="line">                <span class="keyword">return</span> RpcResponse.success(grabRedEnvelopeInfoVO);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将此已经抢成功的红包id记录到缓存，用于下一次接口请求进来判断，今天是否已经抢成功三次了，当前红包是否已经抢过了</span></span><br><span class="line">            recordGrabSuccess(userId, redEnvelopeId);</span><br><span class="line">            grabRedEnvelopeInfoVO.setGain(<span class="keyword">true</span>);</span><br><span class="line">            grabRedEnvelopeInfoVO.setType(GAIN.getType());</span><br><span class="line">            grabRedEnvelopeInfoVO.setPrice(redEnvelopeItemDO.getPrice());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，对与抢红包这个接口就算时基本优化完成了。目前从整体接口逻辑来看，我们做了的优化如下：</p></li></ol><table><thead><tr><th align="center">业务逻辑</th><th align="center">优化前</th><th align="center">优化后</th><th align="center">好处</th></tr></thead><tbody><tr><td align="center">查询是否报名成功</td><td align="center">SQL查询报名表</td><td align="center">查询缓存</td><td align="center">性能提升</td></tr><tr><td align="center">查询一天成功抢红包的次数</td><td align="center">SQL查询</td><td align="center">查询一次缓存</td><td align="center">性能提升</td></tr><tr><td align="center">查询是否已经抢过了当前红包</td><td align="center">SQL查询</td><td align="center">利用上面的缓存查询结果即可</td><td align="center">性能提升</td></tr><tr><td align="center">获取一个子红包id</td><td align="center">LPOP</td><td align="center">LPOP（不变）</td><td align="center">不变</td></tr><tr><td align="center">查询子红包Id缓存List的剩余长度</td><td align="center">LLEN</td><td align="center">省略此次查询</td><td align="center">性能提升</td></tr><tr><td align="center">分布式锁</td><td align="center">锁位置不对，不一定能释放，锁带有超时时间，线程自旋获取锁，影响接口吞吐量</td><td align="center">优化锁位置，不自旋等待，获取不到锁直接返回</td><td align="center">性能提升</td></tr><tr><td align="center">记录红包明细，更细子红包状态</td><td align="center">子红包在表中和缓存中数据可能不一致，并且没有关心事务结果</td><td align="center">保证子红包在表中和缓存的一致性，关心事务结果</td><td align="center">可靠性提升</td></tr></tbody></table><p>经过这么一番优化后，结果的性能提升是可以预估的。几乎所有的读操作全都打到了缓存上。而真正能写次数最多只有红包设定的子红包个数次。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>​ 这样就算优化完了吗？当然还没有！对于高并发的处理，接口仅仅是比较重要的一步罢了。在后续的文章中，我将继续从其他角度对此项目进行优化。</p></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/" title="《高并发红包炸弹项目性能优化》系列三：接口性能优化" target="_blank" rel="external">https://sombreknight.gitee.io/2021/01/15/N2ci7yWyasJw5Jbu/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/SombreKnight" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/SombreKnight" target="_blank"><span class="text-dark">张晨曦</span><small class="ml-1x">Java工程师</small></a></h3><div>业精于勤，荒于嬉！</div></div></figure></div></div></div></article><section id="comments"></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="next"><a href="/2021/01/14/0z9h4N46Yu0gPPfg/" title="《高并发红包炸弹项目性能优化》系列二：方案设计"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button><div class="bar-right"></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>感谢您的支持，我会继续努力的!</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/SombreKnight" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/SombreKnight" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2021 张晨曦<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script><script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"a5da84bef780e059a1e8",clientSecret:"f9dcc6152b0022fde05eb1dc81fb832311b62fb4",repo:"blog-comments",owner:"SombreKnight",admin:["SombreKnight"],id:md5(location.pathname),distractionFreeMode:!0});gitalk.render("comments")</script></body></html>